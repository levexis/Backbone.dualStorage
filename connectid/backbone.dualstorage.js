// Generated by CoffeeScript 1.6.3
/*
 Backbone dualStorage Adapter v1.1.0

 A simple module to replace `Backbone.sync` with *localStorage*-based
 persistence. Models are given GUIDS, and saved into a JSON object. Simple
 as that.

 */
if ( typeof window.debug === 'undefined' ) window.debug = { log : console.log};

(function () {
    var S4, backboneSync, callbackTranslator, dualsync, localsync, modelUpdatedWithResponse, onlineSync, parseRemoteResponse, result;

    /*
     * returns true if id matches regex pattern which implies it's a temporary local key
     * @param string id to test
     */
    function isClientKey( id ) {
        return (!!id && id.length === 36 && id.match( /-/g ).length === 4);
    }

    // contains client key to remote key values
    var _keys = {};
// TODO: NEEDS TO BE SMART ABOUT POSTS FIRST AND ADD PUTS BACK TO QUEUE AND THEN DELETES
// ASYNC=FALSE IS NOT RELIABLE AND KEY MAPPINGS ARE NOT THERE WHEN REQUESTS
// ARE QUEUED.   
    Backbone.Collection.prototype.syncDirty = function () {
        var id, ids, model, store, url, _i, _len, _results,
            that = this;
        url = result( this, 'url' );
        store = localStorage.getItem( '' + url + '_dirty' );
        ids = (store && store.split( ',' )) || [];
        _results = [];
        for ( _i = 0, _len = ids.length; _i < _len; _i++ ) {
            id = ids[_i];
            console.log( 'syncing for update', id, this );
            model = this.get( id );
            if ( !model ) throw new Error( 'dirty model id [' + id + ']' );
            // if the model is new (has a backbone id) then remove the id so creates new record
            // the local cache is cleared when the data is refreshed from server
            console.log( 'syncing for update', id, model, this.model.prototype.idAttribute, model.get( this.model.prototype.idAttribute ), isClientKey( model.get( this.model.prototype.idAttribute ) ), this );
            if ( isClientKey( id ) ) {
                // have we already got a key
                if ( _keys[id] === 'undefined' ) {
                    // remove temporary id on new record creation
                    if ( this.model.prototype.idAttribute ) model.unset( this.model.prototype.idAttribute );
                    // and remove the id so posts new
                    delete model.id;
                    console.log( 'new model', model );
                    model.clientId = id;
                    // this creates a stub which may get referenced by later requests if fired synchronous
                    // have called it stub so can trace if it is passed by reference
                    _keys[id] = 'stub';
                } else {
                    if ( this.model.prototype.idAttribute ) model.set( this.model.prototype.idAttribute, _keys[id] );
                    // and remove the id so posts new
                    model.id = _keys[id];
                }
            }
            model.url = url;

            //TODO: daisy chain?
            // hacky approach to keeping in sync - unlikely to work as will always default to last in thread before making requests
            // might work with callbacks
            $.ajaxSetup( {
                async : model.id ? true : false
            } );
            // now could put personas in here
            _results.push( model.save( {
                    dualsync : true,
                    remote : true
                },
                { success : function ( model, response ) {
                    // this is not perfect but it keeps things simple, as may still be callbacks - could use underscore method to count call backs
                    // idea is to show dirty data until fetch starts after all updates have been sent
                    // otherwise you get a blank list
                    // is the scope ok with these on multiple updates
                    localStorage.removeItem( '' + model.url + '_dirty' );
//                    console.log( 'done ' + model.url + '_dirty' );
                    if ( model.clientId ) {
                        console.log( 'mapping', model.clientId, 'to', response[ (that.model.prototype.idAttribute || 'id') ] );
                        _keys[ model.clientId ] = response[ (that.model.prototype.idAttribute || 'id') ];
                        delete model.clientId;
                        // re-enable async if disabled
                        $.ajaxSetup( { async : true } );
                    }
                    delete model.url;
                },
                    error : function ( model, xhr, options ) {
                        // remove dirty if error returned from backend, if status is 0 then that means the server timed out so should try again
                        if ( xhr.status ) {
                            localStorage.removeItem( '' + model.url + '_dirty' );
                            debug.log( 'sync error', model.url + 'dirty', xhr );
                            delete model.url;
                        }
                        // re-enable async if disabled
                        $.ajaxSetup( { async : true } );
                    }

                } )
            );
        }
//    localStorage.removeItem('' + url + '_dirty'); // this has been moved so we show dirty data until updates have been done
        return _results;
    };
    Backbone.Collection.prototype.syncDestroyed = function () {
        var id, ids, model, store, url, _i, _len, _results, params = {};
        url = result( this, 'url' );
        store = localStorage.getItem( '' + url + '_destroyed' );
        ids = (store && store.split( ',' )) || [];
        _results = [];
        for ( _i = 0, _len = ids.length; _i < _len; _i++ ) {
            id = ids[_i];
            // remove model
            if ( this.model.prototype.idAttribute ) {
                params[this.model.prototype.idAttribute] = id;
            } else {
                params.id = id;
            }
            model.url = url;
            model = new this.model( params );
            model.collection = this;
            _results.push( model.destroy( {
                success : function ( model ) {
// TODO SHOULD REMOVE ID FROM ARRAY NOT DELETE THE WHOLE THING AS IF DELETES ARE INTERUPTED WILL BE MISSED
                    localStorage.removeItem( '' + model.url + '_dirty' );
                    console.log( 'del ' + model.url + '_destroyed' );
                    delete model.url;
                },
                error : function ( model, xhr, options ) {
                    // remove dirty if error returned from backend, if status is 0 then that means the server timed out so should try again
                    if ( xhr.status ) {
                        localStorage.removeItem( '' + url + '_destroyed' );
                        delete model.url;
                    }
                }
            } ) );
        }
//  see note above, we want to ensure that whilst in process of syncing we see old data until updates have completed    
//    localStorage.removeItem('' + url + '_destroyed');
        return _results;
    };
    /*
     * @returns array of xhr requests generated
     */
    Backbone.Collection.prototype.syncDirtyAndDestroyed = function () {

        var that = this;
        // if called before local copy loaded then do a localSync first
        if ( !this.models.length ) {
//        console.log ('read');
            var models = this.fetch( { dirtyLoad : true,
                success : function () {
                    return _dirtyCB( that );
                }
            } );
        } else {
            return _dirtyCB( this );
        }
        function _dirtyCB( that ) {
            var dirty = that.syncDirty();
            // underscore depency - should be in shared libs
            var hooks = _.union( dirty, that.syncDestroyed() );
//        console.log('merging',dirty , that.syncDestroyed(),hooks);
            return hooks;
        }

    };

    S4 = function () {
        return (((1 + Math.random()) * 0x10000) | 0).toString( 16 ).substring( 1 );
    };

    window.Store = (function () {
        Store.prototype.sep = '';

        function Store( name ) {
            this.name = name;
            this.records = this.recordsOn( this.name );
        }

        Store.prototype.generateId = function () {
            return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();
        };

        Store.prototype.save = function () {
            return localStorage.setItem( this.name, this.records.join( ',' ) );
        };

        Store.prototype.recordsOn = function ( key ) {
            var store;
            store = localStorage.getItem( key );
            return (store && store.split( ',' )) || [];
        };

        Store.prototype.dirty = function ( model ) {
            var dirtyRecords;
            dirtyRecords = this.recordsOn( this.name + '_dirty' );
            if ( !_.include( dirtyRecords, model.id.toString() ) ) {
                dirtyRecords.push( model.id );
                localStorage.setItem( this.name + '_dirty', dirtyRecords.join( ',' ) );
            }
            return model;
        };

        Store.prototype.clean = function ( model, from ) {
            var dirtyRecords, store;
            store = '' + this.name + '_' + from;
            dirtyRecords = this.recordsOn( store );
            if ( _.include( dirtyRecords, model.id.toString() ) ) {
                localStorage.setItem( store, _.without( dirtyRecords, model.id.toString() ).join( ',' ) );
            }
            return model;
        };

        Store.prototype.destroyed = function ( model ) {
            var destroyedRecords;
            destroyedRecords = this.recordsOn( this.name + '_destroyed' );
            if ( !_.include( destroyedRecords, model.id.toString() ) ) {
                destroyedRecords.push( model.id );
                localStorage.setItem( this.name + '_destroyed', destroyedRecords.join( ',' ) );
            }
            return model;
        };

        Store.prototype.create = function ( model, recursive ) {
            if ( !_.isObject( model ) ) {
                return model;
            }
            if ( model instanceof Backbone.Collection ) {
                // seems to have a problem when only one record returned
                if ( recursive ) throw new Error( 'nested collections cannot be stored' );
                var that = this;
                _.each( model.models, function ( inModel ) {
//          console.log ('recursive create',inModel);
                    that.create( inModel, true );
                } );
                return model;
            }

            if ( !model.id ) {
                model.id = this.generateId();
                model.set( model.idAttribute, model.id );
            }
//      console.log('storing', this.name + this.sep + model.id, JSON.stringify(model), model);
            localStorage.setItem( this.name + this.sep + model.id, JSON.stringify( model ) );
            this.records.push( model.id.toString() );
            this.save();
            return model;
        };

        Store.prototype.update = function ( model ) {
            localStorage.setItem( this.name + this.sep + model.id, JSON.stringify( model ) );
            if ( !_.include( this.records, model.id.toString() ) ) {
                this.records.push( model.id.toString() );
            }
            this.save();
            return model;
        };

        Store.prototype.clear = function () {
            var id, _i, _len, _ref;
            _ref = this.records;
            for ( _i = 0, _len = _ref.length; _i < _len; _i++ ) {
                id = _ref[_i];
                localStorage.removeItem( this.name + this.sep + id );
            }
            this.records = [];
            return this.save();
        };

        Store.prototype.hasDirtyOrDestroyed = function () {
//      console.log('dirty check ', this.name + '_dirty' , localStorage.getItem(this.name + '_dirty') , !_.isEmpty(localStorage.getItem(this.name + '_dirty')) );
            return !_.isEmpty( localStorage.getItem( this.name + '_dirty' ) ) || !_.isEmpty( localStorage.getItem( this.name + '_destroyed' ) );
        };

        Store.prototype.find = function ( model ) {
            return JSON.parse( localStorage.getItem( this.name + this.sep + model.id ) );
        };

        Store.prototype.findAll = function () {
            var id, _i, _len, _ref, _results;
            _ref = this.records;
            _results = [];
            for ( _i = 0, _len = _ref.length; _i < _len; _i++ ) {
                id = _ref[_i];
                _results.push( JSON.parse( localStorage.getItem( this.name + this.sep + id ) ) );
            }
            return _results;
        };

        Store.prototype.destroy = function ( model ) {
            localStorage.removeItem( this.name + this.sep + model.id );
            this.records = _.reject( this.records, function ( record_id ) {
                return record_id === model.id.toString();
            } );
            this.save();
            return model;
        };

        return Store;

    })();

    callbackTranslator = {
        needsTranslation : Backbone.VERSION === '0.9.10',
        forBackboneCaller : function ( callback ) {
            if ( this.needsTranslation ) {
                return function ( model, resp, options ) {
                    return callback.call( null, resp );
                };
            } else {
                return callback;
            }
        },
        forDualstorageCaller : function ( callback, model, options ) {
            if ( this.needsTranslation ) {
                return function ( resp ) {
                    return callback.call( null, model, resp, options );
                };
            } else {
                return callback;
            }
        }
    };

    localsync = function ( method, model, options ) {
        var isValidModel, preExisting, response, store;
        isValidModel = (method === 'clear') || (method === 'hasDirtyOrDestroyed');
        isValidModel || (isValidModel = model instanceof Backbone.Model);
        isValidModel || (isValidModel = model instanceof Backbone.Collection);
        if ( !isValidModel ) {
            throw new Error( 'model parameter is required to be a backbone model or collection.' );
        }
        store = new Store( options.storeName );
//    console.log ('store', options.storeName, store );
        response = (function () {
            switch ( method ) {
                case 'read':
                    if ( model.id ) {
                        return store.find( model );
                    } else {
                        return store.findAll();
                    }
                    break;
                case 'hasDirtyOrDestroyed':
                    return store.hasDirtyOrDestroyed();
                case 'clear':
                    return store.clear();
                case 'create':
                    if ( !(options.add && !options.merge && (preExisting = store.find( model ))) ) {
                        model = store.create( model );
                        if ( options.dirty ) {
                            store.dirty( model );
                        }
                        return model;
                    } else {
                        return preExisting;
                    }
                    break;
                case 'update':
                    store.update( model );
                    if ( options.dirty ) {
                        return store.dirty( model );
                    } else {
                        return store.clean( model, 'dirty' );
                    }
                    break;
                case 'delete':
                    store.destroy( model );
                    if ( options.dirty ) {
                        return store.destroyed( model );
                    } else {
                        if ( model.id.toString().length === 36 ) {
                            return store.clean( model, 'dirty' );
                        } else {
                            return store.clean( model, 'destroyed' );
                        }
                    }
            }
        })();
        if ( response != null ? response.attributes : void 0 ) {
            response = response.attributes;
        }
        if ( !options.ignoreCallbacks ) {
            if ( response ) {
                options.success( response );
            } else {
                options.error( 'Record not found' );
            }
        }
        return response;
    };

    result = function ( object, property ) {
        var value;
        if ( !object ) {
            return null;
        }
        value = object[property];
        if ( _.isFunction( value ) ) {
            return value.call( object );
        } else {
            return value;
        }
    };

    parseRemoteResponse = function ( object, response ) {
        if ( !(object && object.parseBeforeLocalSave) ) {
            return response;
        }
        if ( _.isFunction( object.parseBeforeLocalSave ) ) {
            return object.parseBeforeLocalSave( response );
        }
    };

    modelUpdatedWithResponse = function ( model, response ) {
        var modelClone;
        modelClone = model.clone();
        modelClone.set( modelClone.parse( response ) );
        return modelClone;
    };

    backboneSync = Backbone.sync;

    onlineSync = function ( method, model, options ) {
        options.success = callbackTranslator.forBackboneCaller( options.success );
        options.error = callbackTranslator.forBackboneCaller( options.error );
        return backboneSync( method, model, options );
    };


    // model contains the model being CUD so collection is in model.collection
    // if reading then called in collection context so colection model then conatins models
    // our config is stored in the collection prototype
    dualsync = function ( method, model, options ) {
        var error, local, originalModel, success , returned , dirty , hooks, _success
           collection = model.collection || this;
        options = options || {};
        // dirtyLoad route is used internaly to fetch dirty records for sync before fetch
        // todo: factor this out?
        if ( options.dirtyLoad ) return localsync( method, model, options );

        function _doXHR ( successFn, errorFn ) {
            if ( !dirty ) {
                return onlineSync( method, model, options );
            } else {
                // sync after dirty business taken care of
                return $.when.apply( $ , hooks ).then( function () {  return onlineSync( method, model , options ); } ,
                    function () {  return success( localsync( method, model, options ) ); } );
            }
        }

        options.storeName = result( collection, 'url' ) || result( model, 'url' );
        options.success = callbackTranslator.forDualstorageCaller( options.success, model, options );
        options.error = callbackTranslator.forDualstorageCaller( options.error, model, options );
        // if isOnline not set defaults to navigator.onLine or true if not available
        options.isOnline =  options.isOnline ||
            result( collection, 'isOnline' );
        if (typeof options.isOnline !== 'boolean') {
            if  ( typeof navigator !=='undefined') {
                options.isOnline = navigator.onLine;
            } else {
                options.isOnline = true;
            }
        }
        // dual syncing only happens when online, can be passed as am option or on collection
        options.dualSync = options.isOnline &&
            ( options.dualSync  ||
            result( collection, 'dualSync' ) ||
            result( collection, 'remote' ) && result( collection, 'local' ) );
        // indicates currently online, can be a function, defaults to navigator.Online
        options.return = options.return ||
            result( collection, 'return' ) ||
            'local';

        if ( typeof options.isOnline === 'function' ) options.isOnline = options.isOnline();

//        console.log('dualSync', method, options );

        // single sync, simple mode
        if ( !options.isOnline || !options.dualSync ) {

//      console.log( 'single sync' , options.remote , options.dualSync , model.dualSync , model );
            // if there is no local copy then always tries remote, regardless off isOnline - this is default BackBone behaviour
            if ( options.isOnline &&
                ( result( model, 'remote' ) || result( collection , 'remote' ) ) ) {
                return onlineSync( method, model, options );
            } else {
                // sets the dirty flag on any changes made in local mode if dualSync
                if ( result( model, 'local' ) || result( collection, 'local' ) ) {
                    options.dirty = options.dirty || options.dualSync || ( collection && collection.dualSync);
                    local = result( model, 'local' ) || result( collection , 'local' );
                    return localsync( method, model, options );
                } else {
                    // no local or remote sync, implies not using dualSync features - eg obile validate
                    return onlineSync( method, model, options );
                }
            }
        } else {
            // in dual sync mode, ignoreCallbacks for local syncing as will be done remotely
            options.ignoreCallbacks = true;
            success = options.success || function () { return; };
            error = options.error;
            // check if we have dirty records to deal with
            dirty = localsync( 'hasDirtyOrDestroyed', model, options );
            // todo: check not already syncing from previous request?
            if (dirty) hooks = collection.syncDirtyAndDestroyed();
            switch ( method ) {
                // if got unsynced local changes will return local copy only
                case 'read':
                    if ( options.return === 'local' || dirty ) {
                        returned = localsync( method, model, options );
                    }
                    // clear and refresh local model on refresh, what if there is already a success method?
                    options.success = function ( resp, status, xhr ) {
                        //          console.log ('not dirty',model);
                        var collection, modelAttributes, responseModel, _i, _len;
                        resp = parseRemoteResponse( model, resp );
                        if ( !options.add ) {
                            // refreshes local copy unless you set the add option
                            localsync( 'clear', model, options );
                        }
                        // assumes response is a collection if returned an array
                        if ( _.isArray( resp ) ) {
                            collection = model;
                            for ( _i = 0, _len = resp.length; _i < _len; _i++ ) {
                                modelAttributes = resp[_i];
                                responseModel = modelUpdatedWithResponse( new collection.model, modelAttributes );
                                localsync( 'create', responseModel, options );
                            }
                        } else {
                            responseModel = modelUpdatedWithResponse( new model.constructor, resp );
                            localsync( 'create', responseModel, options );
                        }
                        return _success( resp, status, xhr );
                    };
                    options.error = function ( resp ) {
                        // will returns local copy if error from say a timeout
                        return success( localsync( method, model, options ) );
                    };
                    // return local or remote
                    if ( returned) {
                        // fetch the remote data and populate cache in background
                        _success = function () { console.log ('lazy callback'); };
                        _doXHR (  function () {  return onlineSync( method, model , options ); } );
                        return success (returned);
                    } else {
                        // call success on xhr.success
                        _success = success;
                        return _doXHR (  function () {  return onlineSync( method, model , options ); },
                            function () {  return success( localsync( method, model, options ) ); }
                        );
                    }
                    break;
                case 'create':
                    options.success = function ( resp, status, xhr ) {
                        var updatedModel;
                        updatedModel = modelUpdatedWithResponse( model, resp );
                        localsync( method, updatedModel, options );
                        return success( resp, status, xhr );
                    };
                    options.error = function ( resp ) {
                        // error on create adds to dirty was regardless of error number and never calls error callback - now calls error method - not sure what this
                        if ( resp.status === 0 ) { // code 0 implies connectivity error
                            options.dirty = true;
                            return success( localsync( method, model, options ) );
                        } else if ( typeof error === 'function' ) {
                            /* TODO - where did this come from is this correct */
                            // remove created record, assuming this only gets called with a collection
                            if ( model.collection.length ) model.collection.pop();
//console.log('create error ' , resp , model );
                            return error( method, model, options );
                        }
                    };
                    return onlineSync( method, model, options );
                case 'update':
                    if ( _.isString( model.id ) && model.id.length === 36 ) {
                        originalModel = model.clone();
                        options.success = function ( resp, status, xhr ) {
                            var updatedModel;
                            updatedModel = modelUpdatedWithResponse( model, resp );
                            localsync( 'delete', originalModel, options );
                            localsync( 'create', updatedModel, options );
                            return success( resp, status, xhr );
                        };
                        options.error = function ( resp ) {
                            options.dirty = true;
                            return success( localsync( method, originalModel, options ) );
                        };
                        model.set( {
                            id : null
                        } );
                        return onlineSync( 'create', model, options );
                    } else {
                        options.success = function ( resp, status, xhr ) {
                            var updatedModel;
                            updatedModel = modelUpdatedWithResponse( model, resp );
                            localsync( method, updatedModel, options );
                            return success( resp, status, xhr );
                        };
                        options.error = function ( resp ) {
                            options.dirty = true;
                            return success( localsync( method, model, options ) );
                        };
                        return onlineSync( method, model, options );
                    }
                    break;
                case 'delete':
                    if ( _.isString( model.id ) && model.id.length === 36 ) {
                        return localsync( method, model, options );
                    } else {
                        options.success = function ( resp, status, xhr ) {
                            localsync( method, model, options );
                            return success( resp, status, xhr );
                        };
                        options.error = function ( resp ) {
                            options.dirty = true;
                            return success( localsync( method, model, options ) );
                        };
                        return onlineSync( method, model, options );
                    }
            }
        }
    };

    Backbone.sync = dualsync;

}).call( this );
